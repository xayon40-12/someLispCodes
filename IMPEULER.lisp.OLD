;use implicite euler and newton method to solve

; u(n+1) = u(n) - f(u(n))/f'(u(n))
; u = u - h*f(u)/(f(u+h)-f(u))        h << 1
(let ((dx 0.1)
      (dt 0.1)
      (D 1)
      (n 64)
      (e 0.001)
      (nc 1/3)
      (m2 1))


  (defun show (x)
    (print (spark (loop for i across x collect i))); :min -10 :max 110
    nil)
  (compile 'show)

  (defun xi ()
    (let ((arr (make-array n)))
      (dotimes (i n) (setf (aref arr i) (* (- (random 2.0) 1.0) (sqrt (/ (* 3.0 2 D nc) dx dt)))))
      arr))
  (compile 'xi)

  (defun fi (x x- u i &optional (di -1))
    (let ((l (+ (aref x (mod (1- i) n)) (if (= di 0) e 0)))
          (m (+ (aref x i)              (if (= di 1) e 0)))
          (m- (aref x- i))
          (r (+ (aref x (mod (1+ i) n)) (if (= di 2) e 0)))
          (mu (aref u i))
          (ru (aref u (mod (1+ i) n))))
      (+ m- (- m) (* dt (+ (* (/ (* D m2) nc dx dx) (+ l (* -2 m) r)) (/ (- ru mu) dx))))))
  (compile 'fi)

  (defun f (x x- u)
    (let ((arr (make-array n)))
      (dotimes (i n) (setf (aref arr i) (fi x x- u i)))
      arr))
  (compile 'f)

  (defun ff (f x x- u)
    (let ((arr (make-array `(,n 5))))
      (dotimes (i n)
        (dotimes (j 3)
          (setf (aref arr i (+ 1 j)) (/ (- (fi x x- u i j) (aref f i)) e))))
      arr))
  (compile 'ff)

  (defun inv (x x- u)
    (let* ((f (f x x- u))
           (ff (ff f x x- u)))
      (setf (aref ff 0 4) (aref ff 0 1))
      (setf (aref ff (1- n) 0) (aref ff (1- n) 3))
      (dotimes (i (1- n))
        (let ((m (aref ff i 2))
              (p (aref ff (1+ i) 1)))
          (dotimes (j 5) (setf (aref ff i j) (/ (aref ff i j) m)))
          (setf (aref f i) (/ (aref f i) m))
          (decf (aref ff (1+ i) 2) (* (aref ff i 3) p))
          (if (= i (- n 3))
              (decf (aref ff (1+ i) 3) (* (aref ff i 4) p))
              (decf (aref ff (1+ i) 4) (* (aref ff i 4) p)))
          (decf (aref f (1+ i)) (* (aref f i) p))
          (setf (aref ff (1+ i) 1) 0)
          ))
      (let ((m (aref ff (1- n) 2)))
        (dotimes (j 5) (setf (aref ff (1- n) j) (/ (aref ff (1- n) j) m)))
        (setf (aref f (1- n)) (/ (aref f (1- n)) m))
        )
      (dotimes (ii (1- n))
        (let* ((i (- n ii 1))
               (m (aref ff i 2))
               (p (aref ff (1- i) 3)))
          (decf (aref ff (1- i) 2) (* (aref ff i 1) p))
          (if (= i 2)
              (decf (aref ff (1- i) 1) (* (aref ff i 0) p))
              (decf (aref ff (1- i) 0) (* (aref ff i 0) p)))
          (if (< i (- n 1))
              (decf (aref ff (1- i) 4) (* (aref ff i 4) p)))
          (decf (aref f (1- i)) (* (aref f i) p))
          (setf (aref ff (1- i) 3) 0)
          ))
      (let ((m (aref ff 0 2)))
        (dotimes (j 5) (setf (aref ff 0 j) (/ (aref ff 0 j) m)))
        (setf (aref f 0) (/ (aref f 0) m))
        )
      (setf (aref ff 1 0) (aref ff 1 1))
      (dotimes (i (- n 1))
        (decf (aref ff (1+ i) 4) (* (aref ff (1+ i) 0) (aref ff 0 4)))
        (decf (aref f (1+ i)) (* (aref ff (1+ i) 0) (aref f 0))))
      (dotimes (i (- n 1))
        (decf (aref f (- n i 2)) (* (aref ff (- n i 2) 4) (aref f (- n 1)))) )
      f))
  (compile 'inv)

  (defun init ()
    (let ((arr (make-array n)))
      (dotimes (i n) (setf (aref arr i) (* 2 nc (exp (* (- (/ 50 2 (* n n))) (expt (- i (/ n 2)) 2))))))
      arr))
  (compile 'init)

  (defun const ()
    (make-array n :initial-element nc))
  (compile 'const)

  (defun newton (x- u)
    (let ((f nil)
          (x (make-array (length x-))))
      (dotimes (i (length x)) (setf (aref x i) (aref x- i)))
      (dotimes (r 1000)
        (setf f (inv x x- u))
        (if (< (reduce (lambda (a b) (+ a (abs b))) f :initial-value 0) e) (return))
        (dotimes (i n) (decf (aref x i) (aref f i))))
      x))
  (compile 'newton)

  (defun simu (tm)
    (let* ((x (const)))
      (dotimes (i (floor tm dt))
        (setf x (newton x (xi))))
      x))
  (compile 'simu)

  (let ((mean 0)
        (var 0)
        (tot 10)
        (tm 20.0)
        (simu nil))
    (dotimes (i tot)
      (setf simu (simu tm))
      (incf mean (/ (reduce #'+ simu :initial-value 0) n))
      (incf var (/ (reduce (lambda (a b) (+ a (* b b))) simu :initial-value 0) n)))
    (setf mean (/ mean tot))
    (setf var (- (/ var tot) (* mean mean)))
    (princ #"mean: ${mean}, var: ${var}")
    nil)
  )
